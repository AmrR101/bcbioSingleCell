#' Known Markers Detected
#'
#' @note Both the `all` and `known` objects must contain Ensembl gene
#'   identifiers in the `geneID` column. We must avoid any matching operations
#'   based on the gene names, since these change often and can mismatch
#'   easily.
#'
#' @name knownMarkersDetected
#' @family Clustering Utilities
#' @author Michael Steinbaugh
#'
#' @inheritParams general
#' @param all All markers, generated by [Seurat::FindAllMarkers()] return.
#' @param known Known markers [data.frame] imported by
#'   [readCellTypeMarkersFile()] or pulled from internal [cellCycleMarkers]
#'   data.
#' @param alpha Alpha cutoff (adjusted P value; false discovery rate).
#' @param filterPromiscuous Remove markers with poor specificity, that are
#'   present in as many clusters as defined by `promiscuousCutoff`.
#' @param promiscuousCutoff Minimum number of clusters required to consider a
#'   gene marker promiscuous.
#'
#' @return Grouped [tibble].
#'
#' @examples
#' load(system.file("extdata/seuratAllMarkers.rda", package = "bcbioSingleCell"))
#'
#' # Use internal known markers for Homo sapiens
#' knownMarkers <- cellTypeMarkers[["homoSapiens"]]
#'
#' # grouped_df
#' knownMarkersDetected(
#'     all = seuratAllMarkers,
#'     known = knownMarkers) %>%
#'     glimpse()
NULL



# Constructors =================================================================
#' @importFrom dplyr everything filter group_by left_join n pull select
#'   summarize
#' @importFrom rlang !! !!! quo sym syms
.knownMarkersDetected <- function(
    all,
    known,
    alpha = 0.05,
    filterPromiscuous = FALSE,
    promiscuousCutoff = 5L
) {
    .checkSanitizedMarkers(all, stop = TRUE)
    # Check for `geneID` column in both `all` and `known`
    assert_is_subset("geneID", colnames(all))
    assert_is_subset("geneID", colnames(known))
    # Check for `geneID` overlap; avoid accidental organism mismatch
    assert_are_intersecting_sets(known[["geneID"]], all[["geneID"]])
    # Check for valid promiscuous cutoff
    assertIsAnImplicitInteger(promiscuousCutoff)
    assert_all_are_in_left_open_range(promiscuousCutoff, 1L)
    # Group by cell type and arrange by P value
    markers <- all %>%
        # Apply alpha cutoff, before adding cell type annotations
        filter(.data[["padj"]] < alpha) %>%
        # FIXME Rename to `cellType`?
        left_join(known[, c("cell", "geneID")], by = "geneID") %>%
        # FIXME Rename cluster to ident
        # TODO Switch to base R column selection
        select(c("cell", "cluster", "geneID", "geneName"), everything()) %>%
        # TODO Switch to base R methods here
        filter(!is.na(.data[["cell"]])) %>%
        group_by(.data[["cell"]]) %>%
        arrange(.data[["padj"]], .by_group = TRUE)
    if (isTRUE(filterPromiscuous)) {
        # Filter out promiscuous markers present in at least 5 clusters
        promiscuous <- markers %>%
            group_by(!!!syms(c("cell", "geneID", "geneName"))) %>%
            summarize(n = n()) %>%
            filter(n >= !!quo(promiscuousCutoff)) %>%
            pull("geneID")
        if (length(promiscuous)) {
            inform(paste(
                "Promiscuous markers:", toString(promiscuous)
            ))
            markers <- markers %>%
                .[!.[["geneID"]] %in% promiscuous, , drop = FALSE]
        }
    }
    markers
}



# Methods ======================================================================
#' @rdname knownMarkersDetected
#' @export
setMethod(
    "knownMarkersDetected",
    signature(
        all = "grouped_df",
        known = "tbl_df"
    ),
    .knownMarkersDetected
)
