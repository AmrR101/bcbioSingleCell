#' Known Markers Detected
#'
#' @note Both the `all` and `known` objects must contain Ensembl gene
#'   identifiers in the `ensgene` column. We must avoid any matching operations
#'   based on the gene symbols, since these change often and can mismatch
#'   easily.
#'
#' @rdname knownMarkersDetected
#' @name knownMarkersDetected
#' @family Clustering Utilities
#' @author Michael Steinbaugh
#'
#' @inheritParams AllGenerics
#'
#' @param all All markers, generated by [Seurat::FindAllMarkers()] return.
#' @param known Known markers [data.frame] imported by [readMarkersFile()] or
#'   pulled from internal [cellCycleMarkers] data.
#' @param alpha Alpha cutoff (adjusted P value; false discovery rate).
#' @param filterPromiscuous Remove markers with poor specificity, that are
#'   present in as many clusters as defined by `promiscuousCutoff`.
#' @param promiscuousCutoff Minimum number of clusters required to consider a
#'   gene marker promiscuous.
#'
#' @return Grouped [tibble].
#'
#' @examples
#' load(system.file(
#'     file.path("extdata", "seuratAllMarkers.rda"),
#'     package = "bcbioSingleCell"))
#'
#' # grouped_df
#' knownMarkersDetected(
#'     all = seuratAllMarkers,
#'     known = cellTypeMarkers[["hsapiens"]]) %>%
#'     glimpse()
NULL



# Constructors =================================================================
#' @importFrom dplyr everything filter group_by left_join n pull select
#'   summarize
#' @importFrom rlang !! !!! quo sym syms
.knownMarkersDetected <- function(
    all,
    known,
    alpha = 0.05,
    filterPromiscuous = FALSE,
    promiscuousCutoff = 5) {
    .checkSanitizedMarkers(all, stop = TRUE)
    # Check for `ensgene` column in both `all` and `known`
    if (!"ensgene" %in% colnames(all) & "ensgene" %in% colnames(known)) {
        stop("'all' and 'known' objects must contain 'ensgene' column",
             call. = FALSE)
    }
    # Check for `ensgene` overlap; avoid accidental organism mismatch
    if (!any(known[["ensgene"]] %in% all[["ensgene"]])) {
        stop("No 'ensgene' intersect between 'all' and 'known'",
             call. = FALSE)
    }
    # Check for valid promiscuous cutoff
    if (!is.numeric(promiscuousCutoff) | promiscuousCutoff < 2) {
        stop("'promiscuousCutoff' requires a minimum of >= 2 clusters",
             call. = FALSE)
    }
    # Group by cell type and arrange by P value
    markers <- all %>%
        # Apply alpha cutoff, before adding cell type annotations
        filter(.data[["padj"]] < alpha) %>%
        left_join(known[, c("cell", "ensgene")], by = "ensgene") %>%
        select(c("cell", "cluster", "ensgene", "symbol"), everything()) %>%
        filter(!is.na(.data[["cell"]])) %>%
        group_by(.data[["cell"]]) %>%
        arrange(.data[["padj"]], .by_group = TRUE)
    if (isTRUE(filterPromiscuous)) {
        # Filter out promiscuous markers present in at least 5 clusters
        promiscuous <- markers %>%
            group_by(!!!syms(c("cell", "ensgene", "symbol"))) %>%
            summarize(n = n()) %>%
            filter(n >= !!quo(promiscuousCutoff)) %>%
            pull("ensgene")
        if (length(promiscuous) > 0) {
            message(paste(
                "Promiscuous markers:", toString(promiscuous)
            ))
            markers <- markers %>%
                .[!.[["ensgene"]] %in% promiscuous, , drop = FALSE]
        }
    }
    markers
}



# Methods ======================================================================
#' @rdname knownMarkersDetected
#' @export
setMethod(
    "knownMarkersDetected",
    signature(all = "grouped_df",
              known = "tbl_df"),
    .knownMarkersDetected)
