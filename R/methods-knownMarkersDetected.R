#' Known Markers Detected
#'
#' @note Both the `all` and `known` objects must contain Ensembl gene
#'   identifiers in the `geneID` column. We must avoid any matching operations
#'   based on the gene names, since these change often and can mismatch
#'   easily.
#'
#' @name knownMarkersDetected
#' @family Clustering Functions
#' @author Michael Steinbaugh
#'
#' @inheritParams general
#' @param all All markers, generated by [Seurat::FindAllMarkers()] return.
#' @param known Known markers `data.frame` imported by
#'   [readCellTypeMarkersFile()] or pulled from internal [cellCycleMarkers]
#'   data.
#' @param alpha Alpha cutoff (adjusted P value; false discovery rate).
#' @param filterPromiscuous Remove markers with poor specificity, that are
#'   present in as many clusters as defined by `promiscuousCutoff`.
#' @param promiscuousCutoff Minimum number of clusters required to consider a
#'   gene marker promiscuous.
#'
#' @return `grouped_df`, grouped by `cellType`.
#'
#' @examples
#' # grouped_df ====
#' knownMarkersDetected(
#'     all = all_markers_small,
#'     known = cellTypeMarkers[["homoSapiens"]]
#' ) %>%
#'     glimpse()
NULL



# Constructors =================================================================
.knownMarkersDetected.tibble <- function(
    all,
    known,
    alpha = 0.05,
    filterPromiscuous = FALSE,
    promiscuousCutoff = 5L
) {
    stopifnot(.isSanitizedMarkers(all))
    # Check for `geneID` column in both `all` and `known`
    assert_is_subset("geneID", colnames(all))
    assert_is_subset("geneID", colnames(known))
    # Check for `geneID` overlap; avoid accidental organism mismatch
    assert_are_intersecting_sets(known[["geneID"]], all[["geneID"]])
    # Check for valid promiscuous cutoff
    assertIsAnImplicitInteger(promiscuousCutoff)
    assert_all_are_in_left_open_range(promiscuousCutoff, 1L)
    # Group by cell type and arrange by P value
    markers <- all %>%
        # Apply alpha cutoff, before adding cell type annotations
        .[.[["padj"]] < alpha, , drop = FALSE] %>%
        left_join(known[, c("cellType", "geneID")], by = "geneID") %>%
        .[, unique(c(
            "cellType", "cluster", "geneID", "geneName", colnames(.)
        ))] %>%
        .[!is.na(.[["cellType"]]), , drop = FALSE] %>%
        group_by(!!sym("cellType")) %>%
        arrange(!!sym("padj"), .by_group = TRUE)
    if (isTRUE(filterPromiscuous)) {
        # Filter out promiscuous markers present in multiple clusters
        promiscuous <- markers %>%
            group_by(!!!syms(c("cell", "geneID", "geneName"))) %>%
            summarize(n = n()) %>%
            .[.[["n"]] >= promiscuousCutoff, "geneID", drop = TRUE]
        if (length(promiscuous)) {
            inform(paste(
                "Promiscuous markers:", toString(promiscuous)
            ))
            markers <- markers %>%
                .[!.[["geneID"]] %in% promiscuous, , drop = FALSE]
        }
    }
    markers
}



# Methods ======================================================================
#' @rdname knownMarkersDetected
#' @export
setMethod(
    "knownMarkersDetected",
    signature(
        all = "grouped_df",
        known = "tbl_df"
    ),
    .knownMarkersDetected.tibble
)
