---
title: "Seurat Clustering"
author: "`r getOption('author')`"
date: "`r Sys.Date()`"
bibliography: bcbioSinglecell.bib
params:
    subsetID: sampleID
    pcCompute: 20
    pcUse: 15
    outputDir: "."
---

```{r setup, cache=FALSE, include=FALSE}
bcbioSinglecell::downloads()
source("setup.R")
library(Seurat)

# Get bcbioSCSubset object
subsetID <- params$subsetID
if (is.null(subsetID)) {
    stop("Subset name is required")
}
data(list = subsetID)
subset <- get(subsetID)
if (!is(subset, "bcbioSCSubset")) {
    stop("Subset must bcbioSCSubset class object")
}
genomeBuild <- metadata(subset)[["genomeBuild"]]

# Principal components
pcCompute <- params$pcCompute
if (pcCompute > 30) {
    warning("Computation of > 30 PCs is not recommended")
}
pcUse <- params$pcUse
if (pcUse > 25) {
    warning("Usage of > 25 PCs for analysis is not recommended")
}

# Directory paths
markersDir <- file.path(
    normalizePath(params$outputDir),
    "results", "markers")

# knitr arguments
opts_chunk$set(
    cache = TRUE,
    cache.lazy = FALSE,
    cache.path = paste0(subsetID, "_cache/"),
    fig.path = paste0(subsetID, "_files/"),
    results = "asis")
```

```{r header, child="_header.Rmd"}
```

This workflow is adapted from the [Seurat v2 Guided Clustering Tutorial](http://satijalab.org/seurat/pbmc3k_tutorial.html).



# Initialize Seurat (`r subsetID`)

Let's convert our `bcbioSCSubset` object containing the filtered cellular barcodes into a `seurat` object. This step uses [Seurat][]'s `CreateSeuratObject()` with the same filtering cutoffs applied during our initial quality control analysis. Here we are imposing a basic minimum gene-cutoff, but also filtering low quality cells that have a high mitochondrial gene abundance.


## Normalization

When we initialize the `seurat` object, the raw counts stored in the `bcbioSCDataSet` are passed into the `seurat` object. Next, we automatically apply [Seurat][]'s default recommended normalization method. 
This employs global-scaling normalization with `LogNormalize()`, which (1) normalizes the gene expression measurements for each cell by the total expression, (2) multiplies this by a scale factor (10,000 by default), and (3) log-transforms the result.

```{r seurat}
seurat <- as(subset, "seurat")
```

```{r VlnPlot, fig.height=8, fig.width=12}
VlnPlot(seurat, c("nGene", "nUMI", "mitoRatio"), nCol = 3)
```



# Check UMI correlations

`GenePlot()` is typically used to visualize gene-gene relationships, but can be
used for anything calculated by the object (e.g. `seurat@meta.data` columns). Here we are visualizing UMI correlations with genes detected (`nGene`) and mitochondrial abundance (`mitoRatio`).

```{r GenePlot, fig.height=12}
par(mfrow = c(2, 1))
GenePlot(seurat, "nUMI", "nGene")
GenePlot(seurat, "nUMI", "mitoRatio")
```



# Regress out unwanted sources of variation

Your single cell experiment likely contains "uninteresting" sources of variation. This could include not only technical noise, but batch effects, or even biological sources of variation (e.g. cell cycle stage). Regressing these signals out of the analysis can improve downstream dimensionality reduction and clustering [@Buettner:2015hp]. [Seurat][] implements a basic version of this by constructing linear models to predict gene expression based on user-defined variables. [Seurat][] stores the z-scored residuals of these models in the `scale.data` slot, and they are used for dimensionality reduction and clustering.

It is typically recommended to regress out cell-cell variation in gene expression driven by batch, the number of detected molecules, and mitochondrial gene expression. For cycling cells, we can also learn a "cell-cycle" score [@Drop-seq] and regress this out as well.

Here, let's regress effects on gene expression that are due to the number of genes detected (`nGene`), the total counts in the cell (`nUMI`), and the percent mitochondrial content (`mitoRatio`).

```{r RegressOut}
seurat <- RegressOut(seurat, latent.vars = c("nGene", "nUMI", "mitoRatio"))
```



# Detection of variable genes across the single cells

[Seurat][] calculates highly variable genes and focuses on these for downstream analysis. `MeanVarPlot()`, which works by calculating the average expression and dispersion for each gene, placing these genes into bins, and then calculating a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression [@Drop-seq].

```{r MeanVarPlot}
seurat <- MeanVarPlot(seurat)
```



# Linear dimensional reduction

Run PCA using `PCAFast()` on the scaled data. By default, the genes in `seurat@var.genes` are used as input, but can be defined using `pc.genes`. We have typically found that running dimensionality reduction on genes with high-dispersion can improve performance. However, with UMI data - particularly after using `RegressOut()`, we often see that PCA returns similar (albeit slower) results when run on much larger subsets of genes, including the whole transcriptome.

`ProjectPCA()` scores each gene in the dataset (including genes not included in the PCA) based on their correlation with the calculated components. Though we don't use this further here, it can be used to identify markers that are strongly correlated with cellular heterogeneity, but may not have passed through variable gene selection.

```{r PCA}
seurat <- seurat %>%
    PCAFast(pcs.compute = pcCompute, do.print = FALSE) %>%
    ProjectPCA(do.print = FALSE)
```

We can visualize these genes graphically using `VizPCA()`.

```{r VizPCA}
VizPCA(seurat, pcs.use = 1:4)
```

In particular, `PCHeatmap()` allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and genes are ordered according to their PCA scores. Setting `cells.use` to a number plots the "extreme" cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated gene sets.

```{r PCHeatmap, fig.height=12, fig.width=8, warning=FALSE}
# PC1
PCHeatmap(seurat,
          do.balanced = TRUE,
          label.columns = FALSE,
          remove.key = TRUE)
# All PCs used
PCHeatmap(seurat,
          do.balanced = TRUE,
          pc.use = 1:pcUse)
```



# Determine statistically significant principal components

To overcome the extensive technical noise in any single gene for scRNA-seq data, [Seurat][] clusters cells based on their PCA scores, with each PC essentially representing a "metagene" that combines information across a correlated gene set. Determining how many PCs to include downstream is therefore an important step. To accomplish this, we plot the standard deviation ("singular value" for `PCAFast()`) of each PC as an elbow plot with `PCElbowPlot()`.

```{r PCElbowPlot}
PCElbowPlot(seurat, num.pc = pcCompute) +
    ggtitle("pc elbow plot") +
    geom_line() +
    geom_vline(alpha = 0.5,
               color = "green",
               size = 2,
               xintercept = pcUse)
```



# Find clusters and visualize

Here we will use the selected PCs to find clusters of cells via heirarchical clustering, then run t-Distributed Stochastic Neighbor Embedding (t-SNE) analysis [@tSNE].

```{r FindClusters}
seurat <- FindClusters(
    seurat,
    do.sparse = TRUE,
    pc.use = 1:pcUse,
    print.output = FALSE,
    save.SNN = TRUE)
```

```{r RunTSNE}
seurat <- RunTSNE(
    seurat,
    dims.use = 1:pcUse,
    do.fast = TRUE)
```

```{r saveSeurat}
assignAndSaveData(paste0(subsetID, "_seurat"), seurat)
```

```{r TSNEPlot}
TSNEPlot(seurat,
         do.label = TRUE,
         label.size = 6,
         no.legend = TRUE)
TSNEPlot(seurat,
         group.by = "sample.name",
         do.label = TRUE,
         label.size = 6,
         no.legend = TRUE)
```

Note that t-SNE is not PCA! The measurement of distance in a t-SNE plot is difficult to interpret, and is most helpful for the relationships of close neighbors. To better infer separation distance between the putative clusters, let's re-apply PCA.

```{r PCAPlot}
PCAPlot(seurat,
        do.label = TRUE,
        no.legend = TRUE)
PCAPlot(seurat,
        group.by = "sample.name",
        do.label = TRUE,
        no.legend = TRUE)
```



# Cluster quality control

Let's look at the variance in the number of genes detected (`nGene`) and the percentage of mitochondrial gene expression (`mitoRatio`), to see if any abberant cells are clustering.

```{r qc}
FeaturePlot(seurat, "nGene", cols.use = c("grey","green"))
FeaturePlot(seurat, "mitoRatio", cols.use = c("grey","red"))
```



* * *



# Differentially expressed genes (cluster markers)

Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster, compared to all other cells. `FindAllMarkers()` automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

The `min.pct` argument requires a gene to be detected at a minimum percentage in either of the two groups of cells, and the `thresh.test` argument requires a gene to be differentially expressed (on average) by some amount between the two groups. As another option to speed up these computations, `max.cells.per.ident` can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be signficiant and the most highly differentially expressed genes will likely still rise to the top.

Seurat has four tests for differential expression which can be set with the `test.use` parameter: LRT test based on zero-inflated data (`bimod`, default), ROC test (`roc`), t-test (`t`), LRT test based on tobit-censoring models (`tobit`) The ROC test returns the 'classification power' for any individual marker (ranging from 0 - random, to 1 - perfect).

```{r FindAllMarkers}
markers <- FindAllMarkers(seurat, only.pos = TRUE)
```

```{r saveMarkers}
assignAndSaveData(paste0(subsetID, "_markers"), markers)
dir.create(markersDir, recursive = TRUE, showWarnings = FALSE)
write_csv(markers,
          file.path(markersDir, paste0(subsetID, ".csv.gz")))
```


## Top markers per cluster

```{r topMarkers}
topMarkers <- topMarkers(markers)
```



# Visualization

## Cluster heterogeneity

Heatmaps can also be a good way to examine heterogeneity within/between clusters. The `DoHeatmap()` function will generate a heatmap for given cells and genes. In this case, we are plotting the top markers for each cluster.

```{r DoHeatmap, fig.height=12, fig.width=12}
DoHeatmap(seurat,
          genes.use = topMarkers$symbol,
          order.by.ident = TRUE,
          remove.key = TRUE,
          slim.col.label = TRUE,
          # heatmap.2 warning fix
          dendrogram = "none")
```


## Cluster marker plots

There are several tools for visualizing marker expression. `VlnPlot()` generates a violin plot which shows the probability density at different expression levels of the gene for each cluster. As seen below, good marker genes will show strongly in a single cluster. It can also be useful to look at gene/gene correlation with `GenePlot()` which returns a plot similar to a 'FACS' plot with cells colored by cluster identity. Also, the `FeaturePlot()` function is useful for viewing the expression of the gene in the context of all the cells and helps validate the specificity of the marker or the quality of the clustering.


## Top markers per cluster

```{r plotTopMarkers, fig.height=12, fig.width=12}
plotTopMarkers(seurat, topMarkers)
```



# Known marker analysis

## Load known markers

```{r knownMarkers}
knownMarkers <- file.path("meta", "known_markers.xlsx") %>%
    readKnownMarkers(genomeBuild)
```


## Known markers detected

Let's obtain the statistics on our known marker genes from [Seurat][].

```{r knownMarkersDetected}
knownMarkersDetected <- knownMarkersDetected(markers, knownMarkers)
```


## Visualize cluster specificity

```{r plotKnownMarkers, fig.height=12, fig.width=12}
plotKnownMarkers(seurat, knownMarkersDetected)
```



```{r footer, child="_footer.Rmd"}
```
